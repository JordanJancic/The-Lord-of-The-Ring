package lab3_jordanjancic.pkg000269500;

import java.io.File;
import java.io.FileNotFoundException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collections;
import static java.util.Collections.binarySearch;
import java.util.Comparator;
import java.util.Scanner;
import java.util.Set;

/**
 * @author Jordan Jancic, 000269500
 * Lab 3
 * Professor: Mark Yendt
 * Date Completed: October 27, 2019
 *
 * 
 * Search methods discussion.
 * 
 * RESULTS:
 * 
 * Words that are not contained in ArrayList dictionary: 3283            | Runtime: 35365ms.
 * 
 * Using Binary search, number of words not found in dictionary are 3292 | Runtime: 14ms.
 * 
 * Searching the HashSet dictionary, number of words not found are: 3283 | Runtime: 4ms.
 * 
 * 
 *     Using the contains() method on the ArrayList Dictionary, it took a significantly longer
 * time to search through the array. The contains method of the ArrayList runs on O(n) time.
 * The ArrayList search time is relative to the size of the ArrayList.
 * 
 *     Using the Binary Search on the sorted ArrayList Dictionary yielded a much better result
 * than the first search attempt. Binary Search runs at O(log n) time,
 * which one would think that to be the worst logarithmic time, however, in this case, since
 * the data is sorted, getting the results was quite a fast process. 
 * 
 *     Using the contains() method on the Hashset, the results were much faster. The HashSet
 * search runs on O(1) time, therefore, it is constant and will complete the operation 
 * at the same time no matter how large the data set is.
 * 
 * 
 * 
 * 
 */

public class Lab3_jordanJancic000269500 {

    private static DecimalFormat df = new DecimalFormat("0.0000");              //Decinamal format object for proper output formatting.
    
    public static void main(String[] args) {                                    //Main method.
     
    // File is stored in a resources folder in the project
    final String novelName = "resources/TheLordOfTheRings.txt";                 
    final String dictionaryFile = "resources/US.txt";
    
    SimpleHashSet<BookWord> dictionaryHashSet = new SimpleHashSet<>();          //The SimpleHashSet Dictionary.
    
    ArrayList<BookWord> dictionaryArrayList = new ArrayList<>();                //The ArrayList Dictionary.
    
    ArrayList<BookWord> bookWordArrayList = new ArrayList<>();                  //The ArrayList of unique book words.
    
    ArrayList<BookWord> tenMostFrequentWords = new ArrayList<>();               //The ArrayList of the ten most frequent words.
    
    ArrayList<BookWord> allWords = new ArrayList<>();                           //The ArrayList holding all of the books words.
    
    int totalNumberOfWords = 0;                                                 //A variable that tracks the count of all words in the text file.
    int totalNumberOfDictionaryWords = 0;                                       //A variable that tracks the count of all dicitonary words.
    int totalNumberOfNonDictionaryWords = 0;                                    //A variable that tracks the count of all non dicitonary words.
    
    // Read in the dictionary 
    try {
      Scanner fin = new Scanner(new File(dictionaryFile), "UTF-8");
      while (fin.hasNext()) {
          
        String w = fin.next();
        // TODO : Add code to store dictionary words into an appropriate data structure
        
        //dictionaryHashSet.insert(new BookWord(w));
        dictionaryArrayList.add(new BookWord(w));                               //Adds in the dictionary word as a book word object as the strings are generated by the starter code.
        
      }
      
      fin.close();
    } catch (FileNotFoundException e) {
        System.out.println("Exception caught: " + e.getMessage());
    }
    
    //Sorts the ArrayList Dictionary once it is created.
    Collections.sort(dictionaryArrayList, new Comparator<BookWord>() {          

        public int compare(BookWord b1, BookWord b2)
        {
            return String.valueOf(b1.getText()).compareTo(b2.getText());
        }
    });
    
    
    //Populates dictionary hash set
    for (int i = 0; i < dictionaryArrayList.size(); i++) {
        dictionaryHashSet.insert(dictionaryArrayList.get(i));
    }
        
    // Reads in the text file.
    try {
      Scanner fin = new Scanner(new File(novelName));
      fin.useDelimiter("\\s|\"|\\(|\\)|\\.|\\,|\\?|\\!|\\_|\\-|\\:|\\;|\\n");  // Filter - DO NOT CHANGE 
      while (fin.hasNext()) {
        
        String fileWord = fin.next().toLowerCase();
        
        if (fileWord.length() > 0)
        {
            totalNumberOfWords++;                                               //Tracks the total number of novel words.
            allWords.add(new BookWord(fileWord));                               //Adds the novel words to the allWords ArrayList.
            BookWord bw = new BookWord(fileWord);                               //Creates a BookWord object based on the incoming word.

            //Checks if the BookWord ArrayList already contains the incoming word.
            if(bookWordArrayList.contains(new BookWord(fileWord))) {                    
                bookWordArrayList.get(bookWordArrayList.indexOf(bw)).incrementCount();  //If the word is found, it is not added again, however the count of the object is incremented instead.
            }
            //If the word is not found in the BookWord ArrayList, then the current bw object count is incremented and it is added to the list.
            else {
                bw.incrementCount();                                            //Increments book word count.
                bookWordArrayList.add(bw);                                      //Adds word to the ArrayList.
            }
        }         
      }

      fin.close();
      
    } catch (FileNotFoundException e) {
        
        System.out.println("Exception caught: " + e.getMessage());
       
    }
    
    //Searches the SimpleHashSet for the amount of words not found in the dictionary.
    long startNotContainedHash = System.nanoTime();                             //Tracks the start time.
    int wordsFoundHashSet = 0;
    int wordsNotFoundHashSet = 0;
    
        //Iterated over the BookWord ArrayList and checks the HashSet Dictionary to see if it exists in there. If it doesn't, then it is not considered to be a word.
        for (int i = 0; i < bookWordArrayList.size(); i++) {
            
            if(dictionaryHashSet.contains(bookWordArrayList.get(i))) {          //Checks if the HashSet contains the current word.
                totalNumberOfDictionaryWords++;                                 //If it contains it, then the value of total dictionary words is incremented.
            }
            else {
                totalNumberOfNonDictionaryWords++;                              //If it does not contan the current word, then the total number of NON dictionary words are incremented.
            }
            
        }
    long elapsedTimeNotContainedHash = System.nanoTime();                       //Tracks the end time.
    long notContainedHashRun = (elapsedTimeNotContainedHash - startNotContainedHash) / 1000000;         //Stores the runtime.
    
    
    //Searches the BookWord ArrayList for the amount of words not found in the dictionary using built-in Binary Search.
    
    long startNotContainedBinary = System.nanoTime();                           //Tracks task start time.
    
    //Establishes new comparator object to prepare for Binary Search.
    Comparator<BookWord> c = new Comparator<BookWord>() {
        public int compare(BookWord u1, BookWord u2) {
        return u1.getText().compareTo(u2.getText());
      }
    };
    
    int binarySearchResultsNonDictionary = 0;                                   //Tracks count of non dicitonary words for the Binary Search.
    
    //Iterates over the BookWord ArrayList and uses the Binary Search to find the incoming words.
    for (int i = 0; i < bookWordArrayList.size(); i++) {
            
        int index = Collections.binarySearch(dictionaryArrayList, bookWordArrayList.get(i), c);     //Stores the index number returned from the Binary Search.
            
        if(index < 0) {                                                         //If the index number is < 0, then that means the binary search did not find a dictionary word.
            binarySearchResultsNonDictionary++;                                 //Increments non-dictionary word count for Binary Search.
        }  
    }
    long elapsedTimeNotContainedBinary = System.nanoTime();                     //Stores stop time.
    long notContainedBinaryRun = (elapsedTimeNotContainedBinary - startNotContainedBinary) / 1000000;   //Stores Binary Search runtime total.

    

    //Iterates over the BookWord ArrayList and uses the ArrayList Dictionary to find the incoming words.
    long startNotContainedArrayList = System.nanoTime();                        //Stores the start time.
    int totalDictionaryArrayList = 0;                                           //Tracks total count of dictionary words for this search method.
    int totalNonDictionaryArrayList = 0;                                        //Tracks total count of non-dictionary words for this search method.

    //Iterates over the BookWord ArrayList and uses the .Contains() Search to find the incoming words.
    for (int i = 0; i < bookWordArrayList.size(); i++) {
        if(dictionaryArrayList.contains(bookWordArrayList.get(i))) {            //Checks if the dictionary ArrayList contains the BookWord ArrayList item.
            totalDictionaryArrayList++;                                         //If it contains it, then this variable is incremented by one.
        }
        else {                                                                  
            totalNonDictionaryArrayList++;                                      //If it doesn't contain it, then the total of non dictionary words is incremented by one.
        }
    }
    
    long elapsedTimeNotContainedArrayList = System.nanoTime();                  //Tracks end time.
    long notContainedArrayListRun = (elapsedTimeNotContainedArrayList - startNotContainedArrayList) / 1000000;      //racks total runtime of this task.


    System.out.println("PART A");
    
    System.out.println("Total number of words in the novel: " + totalNumberOfWords);                        //Displays total number of novel words.
    
    System.out.println("\nTotal number of unique words in the novel: " + bookWordArrayList.size() + "\n");  //Displays total numbe of unique words.
        
        
    //Finds the 10 most frequent words throughout the entire novel.
    int tempCount = 0;                                                          //Holds a temporary count of the most frequent word.
        
    BookWord firstMostFrequent = null;                                          //Declares the first most frequent word object.
            
    //Iterates over the BookWord ArrayList and looks for the most frequently occurring word.
    for (int j = 0; j < bookWordArrayList.size(); j++) {
        if(bookWordArrayList.get(j).getCount() > tempCount) {                   //If the found word is larger than the temp number, then it is stored.
                    
            firstMostFrequent = bookWordArrayList.get(j);                       //Sets the first most frequent word as this BookWord object.
            tempCount = bookWordArrayList.get(j).getCount();                    //Sets the current word as the temp count to prepare for the next comparison.

        }
    }
            
    tenMostFrequentWords.add(firstMostFrequent);                                //Adds the first word found to the tenMostFrequentWords array.
        
        
    tempCount = 0;                                                              //Resets the temp count.
    BookWord[] currentWord = new BookWord[1];                                   //An array that holds the temporary current BookWord Object.
        
    //A for loop that will run 9 times to add the remaining highest word count objects.
    for (int i = 0; i < 9; i++) {
        tempCount = 0;                                                          //Resets temp count to 0.
        BookWord tempWord = new BookWord("temp");                               //Creates a temporary BookWord Obect.
            
        //Iterates over the entire BookWord array to find the remaining highest counted book words.
        for (int j = 0; j < bookWordArrayList.size(); j++) {
                
            if(!tenMostFrequentWords.contains(bookWordArrayList.get(j)) && bookWordArrayList.get(j).getCount() > tempCount) {   //Checks if the current word is not already in the tenMostFrequentWords ArrayList.
                tempCount = bookWordArrayList.get(j).getCount();                //Tracks the temporary count of the current objects for future comparisons.
                currentWord[0] = bookWordArrayList.get(j);                      //Stores the highest counted object in the object array.
            }      
        }
        tenMostFrequentWords.add(currentWord[0]);                               //Once the loop is complete, we assume that we've found the next highest, and we add it to the final arrayList.
    }

    
    //Displays the 10 most frequent words.
    System.out.println("10 most frequent words: ");
    for (int i = 0; i < tenMostFrequentWords.size(); i++) {
        
        System.out.println("[" + tenMostFrequentWords.get(i).getText()+ "]" + " appears " + tenMostFrequentWords.get(i).getCount() + " times."); 
    }
        
    
    //Displays the words that occur in the novel 64 times.    
    ArrayList<String> count64 = new ArrayList<>();                              //Establishes a new arrayList to store the objects that have a count of 64.
    
    //Iterates over the BookWord ArrayList to find the words that have a count of 64.
    for (int i = 0; i < bookWordArrayList.size(); i++) {                        
            
        //Checks if the current word occurs 64 times.
        if(bookWordArrayList.get(i).getCount() == 64) {                         
            count64.add(bookWordArrayList.get(i).getText());                    //If a word of the required count is found, then it is added to the count64 list.
        }
            
    }
    
    //Sorts the count64 collection of objects.
    Collections.sort(count64);
    
    //Displays the words that are found 64 times.
    System.out.println("\nWords found 64 times: ");
    System.out.println(count64);



    //Checks the novel to see which book characters' names appear closest to the word "ring" in the entire novel. 
    long bStartTime = System.nanoTime();                                        //Tracks the start time of B task.
    ArrayList<Character> characterList = new ArrayList<>();                     //Creates a new Character ArrayList to add character objects to.

    //Iterates over the allWords array to find the characters and how many times they are near the word "ring".
    for (int i = 0; i < allWords.size(); i++) { 
        
    int ringsFound = 0;                                                         //Tracks the count of rings found for the current character.
        
        //Checks to see if the current word matches any of the character names.
        if(allWords.get(i).getText().equals("sauron") || allWords.get(i).getText().equals("frodo") || allWords.get(i).getText().equals("sam") || allWords.get(i).getText().equals("bilbo") || allWords.get(i).getText().equals("gandalf") || allWords.get(i).getText().equals("boromir") || allWords.get(i).getText().equals("aragorn") || allWords.get(i).getText().equals("legolas") || allWords.get(i).getText().equals("gollum") || allWords.get(i).getText().equals("pippin") || allWords.get(i).getText().equals("merry") || allWords.get(i).getText().equals("gimli") || allWords.get(i).getText().equals("saruman") || allWords.get(i).getText().equals("faramir") || allWords.get(i).getText().equals("denethor") || allWords.get(i).getText().equals("treebeard") || allWords.get(i).getText().equals("elrond") || allWords.get(i).getText().equals("galadriel")) {
            
            //Once a valid character is found, we scan the surrounding words.
            
            int j = i - 42;                                                     //Goes back 42 words of the current index to prepare for the search of "ring" words.
            int loopCount = 84;                                                 //Stores the value of how many words we must search to find the "ring" word.
            
            //Runs until loopCount runs out.
            while(loopCount > 0) {                              
                loopCount--;                                                    //increments this variable down.
                j++;                                                            //Index variable incremented by 1 to check the next word.
                
                //Checks if the current word is a ring word.
                if(allWords.get(j).getText().equals("ring")) {
                    ringsFound++;                                               //If the word is a ring word, then it is added to the ring word count.
                }
            }

            Character character = new Character(allWords.get(i).getText());     //Creates a new character object.
                
            //Checks if the character list already contains the current characer.
            if(characterList.contains(character)) {
                characterList.get(characterList.indexOf(character)).incrementCount();                   //If the characterList already contains the current character, then we increment the count.
                characterList.get(characterList.indexOf(character)).addToProximityCount(ringsFound);    //Adds the value of ringsFound to the characters proximity count.
            }
            else {
                character.addToProximityCount(ringsFound);                      //Updates he current character objects proximity count.
                characterList.add(character);                                   //If the character list does not contain the current found character, then it is added to the arrayList.
            }
        }  
    }
    
    //Sorts the Character ArrayList based on the Closeness Attribute.
    Collections.sort(characterList, new Comparator<Character>() {

        public int compare(Character c1, Character c2) {
            return Double.valueOf(c2.getCloseness()).compareTo(c1.getCloseness());
        }
    });
        
    long bElapsedTime = System.nanoTime();                                      //Tracks end time of B task.
    long bRun = (bElapsedTime - bStartTime) / 1000000;                          //Tracks total runtime of B task.

    //Displays final required reports for this lab.
    System.out.println("\nWords that are not contained in ArrayList dictionary: " + totalNonDictionaryArrayList + " | Runtime: " + notContainedArrayListRun + "ms."); 
    System.out.println("Using Binary search, number of words not found in dictionary are " + binarySearchResultsNonDictionary + " | Runtime: " + notContainedBinaryRun + "ms.");  
    System.out.println("Searching the HashSet dictionary, number of words not found are: " + totalNumberOfNonDictionaryWords + " | Runtime: " + notContainedHashRun + "ms.");
    
    
        System.out.println("PART B");
    System.out.println("\nTime to execute Part B: " + bRun + "ms.\n");
        
    //Displays character list properties.
    for (int i = 0; i < characterList.size(); i++) {
        System.out.println("Name:      "+characterList.get(i).getName());
        System.out.println("Count:     "+characterList.get(i).getCount());
        System.out.println("Proximity: "+characterList.get(i).getProximityCount());
        System.out.println("Closeness: " + df.format(characterList.get(i).getCloseness()));
        System.out.println("");
    }
    
    
}// End of Main.
    
}